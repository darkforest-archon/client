"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getResult = exports.isPurchase = exports.ethToWei = exports.weiToEth = exports.weiToGwei = exports.gweiToWei = exports.verifySignature = exports.assertProperlySigned = exports.makeProvider = exports.createContract = exports.waitForTransaction = exports.aggregateBulkGetter = exports.neverResolves = exports.getGasSettingGwei = exports.callWithRetry = void 0;
const constants_1 = require("@darkforest_eth/constants");
const types_1 = require("@darkforest_eth/types");
const ethers_1 = require("ethers");
const json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
const p_retry_1 = __importDefault(require("p-retry"));
const p_timeout_1 = __importDefault(require("p-timeout"));
/**
 * Calls the given function, retrying it if there is an error.
 *
 * @todo Get rid of this, and make use of {@link ContractCaller}.
 */
const callWithRetry = async (
// eslint-disable-next-line @typescript-eslint/no-explicit-any
fn, 
// eslint-disable-next-line @typescript-eslint/no-explicit-any
args = [], onError, maxRetries = constants_1.DEFAULT_MAX_CALL_RETRIES, retryInterval = 1000) => {
    return (0, p_retry_1.default)(() => fn(...args), {
        // TODO: Should we set maxRetryTime?
        retries: maxRetries,
        minTimeout: retryInterval,
        maxTimeout: 60000,
        onFailedAttempt(e) {
            console.error(`error: ${e}`);
            console.log(`retrying (${e.attemptNumber + 1}/${maxRetries})...`);
            if (onError) {
                try {
                    onError(e.attemptNumber, e);
                }
                catch (e) {
                    console.log(`failed executing callWithRetry error handler`, e);
                }
            }
        },
    });
};
exports.callWithRetry = callWithRetry;
/**
 * Given the user's auto gas setting, and the current set of gas prices on the network, returns the
 * preferred gas price. If an invalid {@link AutoGasSetting} is provided, then returns undefined.
 */
function getGasSettingGwei(setting, gasPrices) {
    switch (setting) {
        case types_1.AutoGasSetting.Slow:
            return gasPrices.slow;
        case types_1.AutoGasSetting.Average:
            return gasPrices.average;
        case types_1.AutoGasSetting.Fast:
            return gasPrices.fast;
        default:
            return undefined;
    }
}
exports.getGasSettingGwei = getGasSettingGwei;
/**
 * A function that just never resolves.s
 */
function neverResolves() {
    return new Promise(() => { });
}
exports.neverResolves = neverResolves;
/**
 * A useful utility function that breaks up the proverbial number line (defined by {@code total} and
 * {@code querySize}), and calls {@code getterFn} for each of the sections on the number line.
 *
 * @param total the total amount of of items to get
 * @param querySize the chunk size
 * @param getterFn a function that fetches something, given a start index and end index
 * @param onProgress whenever a chunk is loaded, this function is called with the fraction of
 * individual items that have been loaded so far.
 * @param offset the index to start fetching, can be used to skip previously fetched elements.
 * @returns a list of each of the individual items that were loaded.
 */
const aggregateBulkGetter = async (total, querySize, getterFn, 
// the parameter to this function is a value between 0 and 1. We guarantee at least one call to
// `onProgress` if you provide it. The guaranteed call is the one at the end, where the value is 1.
onProgress, offset = 0) => {
    const promises = [];
    let loadedSoFar = 0;
    for (let page = 0; page * querySize + offset < total; page += 1) {
        const start = page * querySize + offset;
        const end = Math.min((page + 1) * querySize + offset, total);
        const loadedThisBatch = end - start;
        promises.push(new Promise(async (resolve) => {
            let res = [];
            while (res.length === 0) {
                res = await getterFn(start, end);
                loadedSoFar += loadedThisBatch;
                onProgress && onProgress(loadedSoFar / total);
            }
            resolve(res);
        }));
    }
    const unflattenedResults = await Promise.all(promises);
    onProgress && onProgress(1);
    return unflattenedResults.flat();
};
exports.aggregateBulkGetter = aggregateBulkGetter;
/**
 * Given a transaction hash and a JsonRpcProvider, waits for the given transaction to complete.
 */
function waitForTransaction(provider, txHash) {
    return (0, p_retry_1.default)(async (tries) => {
        console.log(`[wait-tx] WAITING ON tx hash: ${txHash} tries ${tries}`);
        try {
            const receipt = await (0, p_timeout_1.default)(provider.getTransactionReceipt(txHash), 30 * 1000);
            if (receipt) {
                console.log(`[wait-tx] FINISHED tx hash: ${txHash} tries ${tries}`);
                return receipt;
            }
            else {
                return Promise.reject(new Error("couldn't get receipt"));
            }
        }
        catch (e) {
            console.error(`[wait-tx] TIMED OUT tx hash: ${txHash} tries ${tries} error:`, e);
            return Promise.reject(e);
        }
    }, {
        // TODO: Should we set maxRetryTime?
        retries: constants_1.DEFAULT_MAX_CALL_RETRIES,
        minTimeout: 2000,
        maxTimeout: 60000,
        factor: 1.5,
        onFailedAttempt(e) {
            console.log(`[wait-tx] SLEEPING tx hash: ${txHash} tries ${e.attemptNumber} sleeping...`);
        },
    });
}
exports.waitForTransaction = waitForTransaction;
/**
 * @param contractAddress the address of the contract you want to connect to
 * @param contractABI a javacript object representing the ABI
 */
function createContract(contractAddress, contractABI, provider, signer) {
    return new ethers_1.Contract(contractAddress, contractABI, signer !== null && signer !== void 0 ? signer : provider);
}
exports.createContract = createContract;
/**
 * Creates a new {@link JsonRpcProvider}, and makes sure that it's connected to xDai if we're in
 * production.
 */
function makeProvider(rpcUrl) {
    let provider;
    if (rpcUrl.startsWith('wss://')) {
        provider = new ethers_1.providers.WebSocketProvider(rpcUrl);
    }
    else {
        provider = new ethers_1.providers.StaticJsonRpcProvider(rpcUrl);
        provider.pollingInterval = 8000;
    }
    return provider;
}
exports.makeProvider = makeProvider;
/**
 * Ensures that the given message was properly signed.
 */
function assertProperlySigned(message) {
    const preSigned = (0, json_stable_stringify_1.default)(message.message);
    if (!verifySignature(preSigned, message.signature, message.sender)) {
        throw new Error(`failed to verify: ${message}`);
    }
}
exports.assertProperlySigned = assertProperlySigned;
/**
 * Returns whether or not the given message was signed by the given address.
 */
function verifySignature(message, signature, address) {
    return ethers_1.utils.verifyMessage(message, signature).toLowerCase() === address;
}
exports.verifySignature = verifySignature;
/**
 * Returns the given amount of gwei in wei as a big integer.
 */
function gweiToWei(gwei) {
    return ethers_1.utils.parseUnits(gwei + '', 'gwei');
}
exports.gweiToWei = gweiToWei;
/**
 * Returns the given amount of wei in gwei as a number.
 */
function weiToGwei(wei) {
    return parseFloat(ethers_1.utils.formatUnits(wei, 'gwei'));
}
exports.weiToGwei = weiToGwei;
/**
 * Returns the given amount of wei in gwei as a number.
 */
function weiToEth(wei) {
    return parseFloat(ethers_1.utils.formatEther(wei));
}
exports.weiToEth = weiToEth;
/**
 * Returns the given amount of eth in wei as a big integer.
 */
function ethToWei(eth) {
    return ethers_1.utils.parseEther(eth + '');
}
exports.ethToWei = ethToWei;
/**
 * Whether or not some value is being transferred in this transaction.
 */
function isPurchase(tx) {
    return tx.value !== undefined && tx.value > 0;
}
exports.isPurchase = isPurchase;
/**
 * When you submit a transaction via {@link TxExecutor}, you are given a {@link PendingTransaction}.
 * This function either resolves when the transaction confirms, or rejects if there is any error.
 */
async function getResult(pendingTransaction) {
    const [_submitted, confirmed] = await Promise.all([
        pendingTransaction.submitted,
        pendingTransaction.confirmed,
    ]);
    return confirmed;
}
exports.getResult = getResult;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTmV0d29yay5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9OZXR3b3JrLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHlEQUFxRTtBQUNyRSxpREFBNkY7QUFDN0YsbUNBQTBGO0FBQzFGLGtGQUE4QztBQUM5QyxzREFBNEI7QUFDNUIsMERBQWdDO0FBS2hDOzs7O0dBSUc7QUFDSSxNQUFNLGFBQWEsR0FBRyxLQUFLO0FBQ2hDLDhEQUE4RDtBQUM5RCxFQUFrQztBQUNsQyw4REFBOEQ7QUFDOUQsT0FBYyxFQUFFLEVBQ2hCLE9BQTJCLEVBQzNCLFVBQVUsR0FBRyxvQ0FBd0IsRUFDckMsYUFBYSxHQUFHLElBQUksRUFDUixFQUFFO0lBQ2QsT0FBTyxJQUFBLGlCQUFLLEVBQUMsR0FBRyxFQUFFLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLEVBQUU7UUFDOUIsb0NBQW9DO1FBQ3BDLE9BQU8sRUFBRSxVQUFVO1FBQ25CLFVBQVUsRUFBRSxhQUFhO1FBQ3pCLFVBQVUsRUFBRSxLQUFNO1FBQ2xCLGVBQWUsQ0FBQyxDQUFDO1lBQ2YsT0FBTyxDQUFDLEtBQUssQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDN0IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxhQUFhLENBQUMsQ0FBQyxhQUFhLEdBQUcsQ0FBQyxJQUFJLFVBQVUsTUFBTSxDQUFDLENBQUM7WUFDbEUsSUFBSSxPQUFPLEVBQUU7Z0JBQ1gsSUFBSTtvQkFDRixPQUFPLENBQUMsQ0FBQyxDQUFDLGFBQWEsRUFBRSxDQUFDLENBQUMsQ0FBQztpQkFDN0I7Z0JBQUMsT0FBTyxDQUFDLEVBQUU7b0JBQ1YsT0FBTyxDQUFDLEdBQUcsQ0FBQyw4Q0FBOEMsRUFBRSxDQUFDLENBQUMsQ0FBQztpQkFDaEU7YUFDRjtRQUNILENBQUM7S0FDRixDQUFDLENBQUM7QUFDTCxDQUFDLENBQUM7QUExQlcsUUFBQSxhQUFhLGlCQTBCeEI7QUFFRjs7O0dBR0c7QUFDSCxTQUFnQixpQkFBaUIsQ0FDL0IsT0FBdUIsRUFDdkIsU0FBb0I7SUFFcEIsUUFBUSxPQUFPLEVBQUU7UUFDZixLQUFLLHNCQUFjLENBQUMsSUFBSTtZQUN0QixPQUFPLFNBQVMsQ0FBQyxJQUFJLENBQUM7UUFDeEIsS0FBSyxzQkFBYyxDQUFDLE9BQU87WUFDekIsT0FBTyxTQUFTLENBQUMsT0FBTyxDQUFDO1FBQzNCLEtBQUssc0JBQWMsQ0FBQyxJQUFJO1lBQ3RCLE9BQU8sU0FBUyxDQUFDLElBQUksQ0FBQztRQUN4QjtZQUNFLE9BQU8sU0FBUyxDQUFDO0tBQ3BCO0FBQ0gsQ0FBQztBQWRELDhDQWNDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixhQUFhO0lBQzNCLE9BQU8sSUFBSSxPQUFPLENBQUMsR0FBRyxFQUFFLEdBQUUsQ0FBQyxDQUFDLENBQUM7QUFDL0IsQ0FBQztBQUZELHNDQUVDO0FBRUQ7Ozs7Ozs7Ozs7O0dBV0c7QUFDSSxNQUFNLG1CQUFtQixHQUFHLEtBQUssRUFDdEMsS0FBYSxFQUNiLFNBQWlCLEVBQ2pCLFFBQTREO0FBQzVELCtGQUErRjtBQUMvRixtR0FBbUc7QUFDbkcsVUFBZ0QsRUFDaEQsTUFBTSxHQUFHLENBQUMsRUFDSSxFQUFFO0lBQ2hCLE1BQU0sUUFBUSxHQUFtQixFQUFFLENBQUM7SUFDcEMsSUFBSSxXQUFXLEdBQUcsQ0FBQyxDQUFDO0lBRXBCLEtBQUssSUFBSSxJQUFJLEdBQUcsQ0FBQyxFQUFFLElBQUksR0FBRyxTQUFTLEdBQUcsTUFBTSxHQUFHLEtBQUssRUFBRSxJQUFJLElBQUksQ0FBQyxFQUFFO1FBQy9ELE1BQU0sS0FBSyxHQUFHLElBQUksR0FBRyxTQUFTLEdBQUcsTUFBTSxDQUFDO1FBQ3hDLE1BQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsU0FBUyxHQUFHLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBQztRQUM3RCxNQUFNLGVBQWUsR0FBRyxHQUFHLEdBQUcsS0FBSyxDQUFDO1FBQ3BDLFFBQVEsQ0FBQyxJQUFJLENBQ1gsSUFBSSxPQUFPLENBQU0sS0FBSyxFQUFFLE9BQU8sRUFBRSxFQUFFO1lBQ2pDLElBQUksR0FBRyxHQUFRLEVBQUUsQ0FBQztZQUNsQixPQUFPLEdBQUcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dCQUN2QixHQUFHLEdBQUcsTUFBTSxRQUFRLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDO2dCQUNqQyxXQUFXLElBQUksZUFBZSxDQUFDO2dCQUMvQixVQUFVLElBQUksVUFBVSxDQUFDLFdBQVcsR0FBRyxLQUFLLENBQUMsQ0FBQzthQUMvQztZQUVELE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNmLENBQUMsQ0FBQyxDQUNILENBQUM7S0FDSDtJQUVELE1BQU0sa0JBQWtCLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBRXZELFVBQVUsSUFBSSxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFNUIsT0FBTyxrQkFBa0IsQ0FBQyxJQUFJLEVBQUUsQ0FBQztBQUNuQyxDQUFDLENBQUM7QUFuQ1csUUFBQSxtQkFBbUIsdUJBbUM5QjtBQUVGOztHQUVHO0FBQ0gsU0FBZ0Isa0JBQWtCLENBQ2hDLFFBQW1DLEVBQ25DLE1BQWM7SUFFZCxPQUFPLElBQUEsaUJBQUssRUFDVixLQUFLLEVBQUUsS0FBSyxFQUFFLEVBQUU7UUFDZCxPQUFPLENBQUMsR0FBRyxDQUFDLGlDQUFpQyxNQUFNLFVBQVUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUV0RSxJQUFJO1lBQ0YsTUFBTSxPQUFPLEdBQUcsTUFBTSxJQUFBLG1CQUFPLEVBQUMsUUFBUSxDQUFDLHFCQUFxQixDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztZQUVqRixJQUFJLE9BQU8sRUFBRTtnQkFDWCxPQUFPLENBQUMsR0FBRyxDQUFDLCtCQUErQixNQUFNLFVBQVUsS0FBSyxFQUFFLENBQUMsQ0FBQztnQkFDcEUsT0FBTyxPQUFPLENBQUM7YUFDaEI7aUJBQU07Z0JBQ0wsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLHNCQUFzQixDQUFDLENBQUMsQ0FBQzthQUMxRDtTQUNGO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixPQUFPLENBQUMsS0FBSyxDQUFDLGdDQUFnQyxNQUFNLFVBQVUsS0FBSyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7WUFDakYsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQzFCO0lBQ0gsQ0FBQyxFQUNEO1FBQ0Usb0NBQW9DO1FBQ3BDLE9BQU8sRUFBRSxvQ0FBd0I7UUFDakMsVUFBVSxFQUFFLElBQUk7UUFDaEIsVUFBVSxFQUFFLEtBQU07UUFDbEIsTUFBTSxFQUFFLEdBQUc7UUFDWCxlQUFlLENBQUMsQ0FBQztZQUNmLE9BQU8sQ0FBQyxHQUFHLENBQUMsK0JBQStCLE1BQU0sVUFBVSxDQUFDLENBQUMsYUFBYSxjQUFjLENBQUMsQ0FBQztRQUM1RixDQUFDO0tBQ0YsQ0FDRixDQUFDO0FBQ0osQ0FBQztBQWpDRCxnREFpQ0M7QUFFRDs7O0dBR0c7QUFDSCxTQUFnQixjQUFjLENBQzVCLGVBQXVCLEVBQ3ZCLFdBQThCLEVBQzlCLFFBQW1DLEVBQ25DLE1BQWU7SUFFZixPQUFPLElBQUksaUJBQVEsQ0FBQyxlQUFlLEVBQUUsV0FBVyxFQUFFLE1BQU0sYUFBTixNQUFNLGNBQU4sTUFBTSxHQUFJLFFBQVEsQ0FBTSxDQUFDO0FBQzdFLENBQUM7QUFQRCx3Q0FPQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLFlBQVksQ0FBQyxNQUFjO0lBQ3pDLElBQUksUUFBUSxDQUFDO0lBRWIsSUFBSSxNQUFNLENBQUMsVUFBVSxDQUFDLFFBQVEsQ0FBQyxFQUFFO1FBQy9CLFFBQVEsR0FBRyxJQUFJLGtCQUFTLENBQUMsaUJBQWlCLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDcEQ7U0FBTTtRQUNMLFFBQVEsR0FBRyxJQUFJLGtCQUFTLENBQUMscUJBQXFCLENBQUMsTUFBTSxDQUFDLENBQUM7UUFDdkQsUUFBUSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUM7S0FDakM7SUFFRCxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDO0FBWEQsb0NBV0M7QUFFRDs7R0FFRztBQUNILFNBQWdCLG9CQUFvQixDQUFDLE9BQStCO0lBQ2xFLE1BQU0sU0FBUyxHQUFHLElBQUEsK0JBQVMsRUFBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUM7SUFFN0MsSUFBSSxDQUFDLGVBQWUsQ0FBQyxTQUFTLEVBQUUsT0FBTyxDQUFDLFNBQW1CLEVBQUUsT0FBTyxDQUFDLE1BQW9CLENBQUMsRUFBRTtRQUMxRixNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixPQUFPLEVBQUUsQ0FBQyxDQUFDO0tBQ2pEO0FBQ0gsQ0FBQztBQU5ELG9EQU1DO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixlQUFlLENBQUMsT0FBZSxFQUFFLFNBQWlCLEVBQUUsT0FBbUI7SUFDckYsT0FBTyxjQUFLLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQyxXQUFXLEVBQUUsS0FBSyxPQUFPLENBQUM7QUFDM0UsQ0FBQztBQUZELDBDQUVDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixTQUFTLENBQUMsSUFBWTtJQUNwQyxPQUFPLGNBQUssQ0FBQyxVQUFVLENBQUMsSUFBSSxHQUFHLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQztBQUM3QyxDQUFDO0FBRkQsOEJBRUM7QUFFRDs7R0FFRztBQUNILFNBQWdCLFNBQVMsQ0FBQyxHQUFjO0lBQ3RDLE9BQU8sVUFBVSxDQUFDLGNBQUssQ0FBQyxXQUFXLENBQUMsR0FBRyxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDcEQsQ0FBQztBQUZELDhCQUVDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixRQUFRLENBQUMsR0FBYztJQUNyQyxPQUFPLFVBQVUsQ0FBQyxjQUFLLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7QUFDNUMsQ0FBQztBQUZELDRCQUVDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQixRQUFRLENBQUMsR0FBVztJQUNsQyxPQUFPLGNBQUssQ0FBQyxVQUFVLENBQUMsR0FBRyxHQUFHLEVBQUUsQ0FBQyxDQUFDO0FBQ3BDLENBQUM7QUFGRCw0QkFFQztBQUVEOztHQUVHO0FBQ0gsU0FBZ0IsVUFBVSxDQUFDLEVBQWdDO0lBQ3pELE9BQU8sRUFBRSxDQUFDLEtBQUssS0FBSyxTQUFTLElBQUksRUFBRSxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUM7QUFDaEQsQ0FBQztBQUZELGdDQUVDO0FBRUQ7OztHQUdHO0FBQ0ksS0FBSyxVQUFVLFNBQVMsQ0FDN0Isa0JBQXNDO0lBRXRDLE1BQU0sQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLEdBQUcsTUFBTSxPQUFPLENBQUMsR0FBRyxDQUFDO1FBQ2hELGtCQUFrQixDQUFDLFNBQVM7UUFDNUIsa0JBQWtCLENBQUMsU0FBUztLQUM3QixDQUFDLENBQUM7SUFFSCxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDO0FBVEQsOEJBU0MifQ==