"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createEthConnection = exports.EthConnection = void 0;
const constants_1 = require("@darkforest_eth/constants");
const events_1 = require("@darkforest_eth/events");
const serde_1 = require("@darkforest_eth/serde");
const ethers_1 = require("ethers");
const json_stable_stringify_1 = __importDefault(require("json-stable-stringify"));
const just_debounce_1 = __importDefault(require("just-debounce"));
const Network_1 = require("./Network");
const xDaiApi_1 = require("./xDaiApi");
/* eslint-disable @typescript-eslint/no-explicit-any */
/**
 * Responsible for
 * 1) loading the contracts
 * 2) connecting to the network
 */
class EthConnection {
    constructor(provider, blockNumber) {
        /**
         * Represents the gas price one would pay to achieve the corresponding transaction confirmation
         * speed.
         */
        this.gasPrices = constants_1.DEFAULT_GAS_PRICES;
        this.contracts = new Map();
        this.loaders = new Map();
        this.provider = provider;
        this.balance = ethers_1.BigNumber.from('0');
        this.blockNumber = blockNumber;
        this.blockNumber$ = (0, events_1.monomitter)(true);
        this.rpcChanged$ = (0, events_1.monomitter)(true);
        this.myBalance$ = (0, events_1.monomitter)(true);
        this.gasPrices$ = (0, events_1.monomitter)();
        this.rpcChanged$.publish(provider.connection.url);
        this.startPolling();
    }
    async reloadContracts() {
        for (const [address, loader] of this.loaders) {
            // Was going to dedupe this with `this.loadContract` but there is no reason to set the loader again.
            const contract = await loader(address, this.provider, this.signer);
            this.contracts.set(address, contract);
        }
    }
    /**
     * Loads a contract into this {@link EthConnection}.
     *
     * @param address The contract address to register the contract against.
     * @param loader The loader used to load (or reload) this contract.
     */
    async loadContract(address, loader) {
        this.loaders.set(address, loader);
        const contract = await loader(address, this.provider, this.signer);
        this.contracts.set(address, contract);
        return contract;
    }
    /**
     * Retreives a contract from the registry. Must exist otherwise this will throw.
     * @param address The address to load from the registry.
     * @returns The contract requested
     */
    getContract(address) {
        const contract = this.contracts.get(address);
        if (!contract) {
            throw new Error(`Contract never loaded. Address: ${address}`);
        }
        return contract;
    }
    /**
     * Changes the RPC url we're connected to, and reloads the ethers contract references.
     */
    async setRpcUrl(rpcUrl) {
        const newProvider = await (0, Network_1.makeProvider)(rpcUrl);
        await this.reloadContracts();
        this.rpcChanged$.publish(newProvider.connection.url);
        this.provider = newProvider;
    }
    /**
     * Changes the ethereum account on behalf of which this {@link EthConnection} sends transactions. Reloads
     * the contracts.
     */
    async setAccount(skey) {
        this.signer = new ethers_1.Wallet(skey, this.provider);
        this.balance = await this.loadBalance(this.signer.address);
        await this.reloadContracts();
    }
    async refreshBalance() {
        if (this.signer) {
            const balance = await this.loadBalance(this.signer.address);
            this.balance = balance;
            this.myBalance$.publish(balance);
        }
    }
    /**
     * Loads gas prices from xDai.
     */
    async refreshGasPrices() {
        var _a;
        this.gasPrices = await (0, xDaiApi_1.getAutoGasPrices)();
        this.gasPrices$.publish(this.gasPrices);
        (_a = this.diagnosticsUpdater) === null || _a === void 0 ? void 0 : _a.updateDiagnostics((d) => (d.gasPrices = this.gasPrices));
    }
    /**
     * Gets a copy of the latest gas prices.
     */
    getAutoGasPrices() {
        return { ...this.gasPrices };
    }
    /**
     * Get the gas price, measured in Gwei, that we should send given the current prices for
     * transaction speeds, and given the user's gas price setting.
     */
    getAutoGasPriceGwei(gasPrices, gasPriceSetting // either auto or the gas price measured in gwei
    ) {
        // if the gas price setting represents an 'auto' choice, return that choice's current price
        const autoPrice = (0, Network_1.getGasSettingGwei)(gasPriceSetting, gasPrices);
        if (autoPrice !== undefined) {
            return autoPrice;
        }
        // if the gas price setting is not an auto choice, it is a string representing the user's
        // preferred gas price, measured in gwei.
        const parsedSetting = parseFloat(gasPriceSetting);
        if (!isNaN(parsedSetting)) {
            return parsedSetting;
        }
        // if the setting has become corrupted, just return an average gas price
        return gasPrices.average;
    }
    getRpcEndpoint() {
        return this.provider.connection.url;
    }
    hasSigner() {
        return !!this.signer;
    }
    subscribeToContractEvents(contract, 
    // map from contract event to function. using type 'any' here to satisfy typescript - each of
    // the functions has a different type signature.
    handlers, eventFilter) {
        const debouncedOnNewBlock = (0, just_debounce_1.default)(this.onNewBlock.bind(this), 1000, true, true);
        this.provider.on('block', async (latestBlockNumber) => {
            debouncedOnNewBlock(latestBlockNumber, contract, handlers, eventFilter);
        });
    }
    /**
     * Whenever we become aware of the fact that there have been one or more new blocks mined on the
     * blockchain, we need to update the internal game state of the game to reflect everything that
     * has happnened in those blocks. The way we find out what happened during those blocks is by
     * filtering all the events that have occured in those blocks to those that represent the various
     * actions that can occur on the game.
     */
    onNewBlock(latestBlockNumber, contract, handlers, eventFilter) {
        const previousBlockNumber = this.blockNumber;
        this.blockNumber = latestBlockNumber;
        this.blockNumber$.publish(latestBlockNumber);
        console.log(`processing events for ${latestBlockNumber - previousBlockNumber} blocks`);
        this.processEvents(Math.min(previousBlockNumber + 1, latestBlockNumber), latestBlockNumber, eventFilter, contract, handlers);
    }
    /**
     * Downloads and processes all the events that have occurred in the given range of blocks.
     *
     * @param startBlock inclusive
     * @param endBlock inclusive
     */
    async processEvents(startBlock, endBlock, eventFilter, contract, 
    // map from contract event name to the handler for that contract event
    handlers) {
        const logs = await this.provider.getLogs({
            fromBlock: startBlock,
            toBlock: endBlock,
            ...eventFilter,
        });
        logs.forEach((log) => {
            const parsedData = contract.interface.parseLog(log);
            const handler = handlers[parsedData.name];
            if (handler !== undefined) {
                handler(...parsedData.args);
            }
        });
    }
    /**
     * Returns the address of the signer, if one was set.
     */
    getAddress() {
        if (!this.signer) {
            return undefined;
        }
        return (0, serde_1.address)(this.signer.address);
    }
    /**
     * Returns the private key of the signer, if one was set.
     */
    getPrivateKey() {
        if (!this.signer) {
            return undefined;
        }
        return this.signer.privateKey;
    }
    /**
     * Gets the signer's nonce, or `0`.
     */
    async getNonce() {
        if (!this.signer) {
            return 0;
        }
        return (0, Network_1.callWithRetry)(this.provider.getTransactionCount.bind(this.provider), [
            this.signer.address,
        ]);
    }
    /**
     * Signs a string, or throws an error if a signer has not been set.
     */
    async signMessage(message) {
        if (!this.signer) {
            throw new Error('no signer was set.');
        }
        return this.signer.signMessage(message);
    }
    /**
     * Returns a version of this message signed by the account that this {@code EthConnectio} is
     * logged in as.
     */
    async signMessageObject(obj) {
        if (!this.signer) {
            throw new Error('no signer was set.');
        }
        const stringified = (0, json_stable_stringify_1.default)(obj);
        const signature = await this.signMessage(stringified);
        return {
            signature,
            sender: this.signer.address.toLowerCase(),
            message: obj,
        };
    }
    /**
     * Gets the balance of the given address (player or contract) measured in Wei. Wei is the base
     * unit in which amounts of Ether and xDai are measured.
     *
     * @see https://ethdocs.org/en/latest/ether.html#denominations
     */
    async loadBalance(address) {
        return await (0, Network_1.callWithRetry)(this.provider.getBalance.bind(this.provider), [address]);
    }
    /**
     * Sends a transaction on behalf of the account that can be set via
     * {@link EthConnection.setAccount}. Throws an error if no account was set.
     */
    sendTransaction(request) {
        if (!this.signer)
            throw new Error(`no signer`);
        return this.signer.sendTransaction(request);
    }
    /**
     * Gets the provider this {@link EthConnection} is currently using. Don't store a reference to
     * this (unless you're writing plugins), as the provider can change.
     */
    getProvider() {
        return this.provider;
    }
    /**
     * Gets the wallet, which represents the account that this {@link EthConnection} sends
     * transactions on behalf of.
     */
    getSigner() {
        return this.signer;
    }
    /**
     * Gets the current balance of the burner wallet this {@link EthConnection} is in charge of.
     */
    getMyBalance() {
        return this.balance;
    }
    /**
     * Returns a promise that resolves when the transaction with the given hash is confirmed, and
     * rejects if the transaction reverts or if there's a network error.
     */
    waitForTransaction(txHash) {
        return (0, Network_1.waitForTransaction)(this.provider, txHash);
    }
    /**
     * For collecting diagnostics.
     */
    setDiagnosticUpdater(diagnosticUpdater) {
        this.diagnosticsUpdater = diagnosticUpdater;
        this.rpcChanged$.subscribe(() => {
            diagnosticUpdater === null || diagnosticUpdater === void 0 ? void 0 : diagnosticUpdater.updateDiagnostics((diagnostics) => (diagnostics.rpcUrl = this.getRpcEndpoint()));
        });
        this.gasPrices$.subscribe((gasPrices) => {
            diagnosticUpdater === null || diagnosticUpdater === void 0 ? void 0 : diagnosticUpdater.updateDiagnostics((diagnostics) => (diagnostics.gasPrices = gasPrices));
        });
    }
    /**
     * Cleans up any important handles.
     */
    destroy() {
        this.stopPolling();
    }
    stopPolling() {
        if (this.gasPricesInterval) {
            clearInterval(this.gasPricesInterval);
        }
        if (this.balanceInterval) {
            clearInterval(this.balanceInterval);
        }
    }
    /**
     * Kicks off an interval that regularly reloads the gas prices from xDai.
     */
    startPolling() {
        this.refreshGasPrices();
        this.gasPricesInterval = setInterval(this.refreshGasPrices.bind(this), constants_1.GAS_PRICES_INTERVAL_MS);
        this.refreshBalance();
        this.balanceInterval = setInterval(this.refreshBalance.bind(this), 1000 * 10);
    }
}
exports.EthConnection = EthConnection;
async function createEthConnection(rpcUrl) {
    const provider = await (0, Network_1.makeProvider)(rpcUrl);
    const blockNumber = await provider.getBlockNumber();
    return new EthConnection(provider, blockNumber);
}
exports.createEthConnection = createEthConnection;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRXRoQ29ubmVjdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9FdGhDb25uZWN0aW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBLHlEQUF1RjtBQUN2RixtREFBZ0U7QUFDaEUsaURBQWdEO0FBUWhELG1DQUE2RTtBQUM3RSxrRkFBOEM7QUFDOUMsa0VBQXFDO0FBRXJDLHVDQUErRjtBQUMvRix1Q0FBNkM7QUFFN0MsdURBQXVEO0FBRXZEOzs7O0dBSUc7QUFDSCxNQUFhLGFBQWE7SUFpRnhCLFlBQW1CLFFBQW1DLEVBQUUsV0FBbUI7UUExQzNFOzs7V0FHRztRQUNLLGNBQVMsR0FBYyw4QkFBa0IsQ0FBQztRQXVDaEQsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQzNCLElBQUksQ0FBQyxPQUFPLEdBQUcsSUFBSSxHQUFHLEVBQUUsQ0FBQztRQUN6QixJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsT0FBTyxHQUFHLGtCQUFTLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO1FBQy9CLElBQUksQ0FBQyxZQUFZLEdBQUcsSUFBQSxtQkFBVSxFQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBQSxtQkFBVSxFQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3BDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBQSxtQkFBVSxFQUFDLElBQUksQ0FBQyxDQUFDO1FBQ25DLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBQSxtQkFBVSxHQUFFLENBQUM7UUFDL0IsSUFBSSxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNsRCxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUVP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